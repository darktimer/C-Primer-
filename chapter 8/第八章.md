##### 通用 I/O 函数简介

必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性。

##### 单字符 I/O：getchar() 和 putchar()

getchar() 和 putchar()，每次只处理一个字符，这也是大部分文本处理程序的核心方法。实际上 getchar() 和  putchar()都不是真正的函数，它们被定义为供预处理器使用的宏。

##### 缓冲区

用户输入的字符被收集并存储在一个称为 **缓冲区 buffer** 的临时存储区。为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个传输节约时间；其次，如果用户输入错误可以修正，当最后按下 Enter 键时才是正确的输入。缓冲区的大小取决系统，常见 512 B，4096 B。

所以有了**缓冲输入**和**无缓冲输入**的区别。无缓冲输入会在输入后**立即回显**输入的内容，缓冲输入会在 Enter 后打印。两种都有用武之地，像游戏这类即时交互程序，就需要程序对用户的输入指令作即时反应。ANSI C和后续的 C 标准规定使用缓冲输入，但提供支持无缓冲输入的函数，原型在 conio.h 头文件中。

缓冲分为两类：完全缓冲 I/O 和行缓冲 I/O。

**完全缓冲 I/O：**当缓冲区填满后才刷新缓冲区，将内容发送至目的地。一般出现在文件输入中。

**行缓冲 I/O：**当出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，按下 Enter 刷新缓冲区。

##### 文件、流和键盘输入

较低层面上，C 可以使用主机操作系统的基本文件工具直接处理文件，直接调用操作系统的函数被称为底层 I\O 。较高层面上，C 可以通过标准 I\O 来处理文件。这是因为计算机系统之间有差异，为所有不同的底层创建标准库不太现实。

系统文件存储差异：有些系统把文件内容存储在一处，文件相关信息存储在另一处；有些系统在文件中创建文件描述。

系统文件处理差异：有些系统用单个换行符标记行末尾；有些系统用回车符和换行符组合标记行末尾。

系统文件大小衡量差异：有些系统用最小字节衡量大小；有些系统用字节块衡量大小。

如果使用标准 I\O 包就不用考虑这些差异。可以用 if(ch=='\n') 来检查换行符，即使系统使用回车符和换行符搭配来标记也可以自行转换。

**流：**C 程序处理的是流而不是直接处理文件，流是一个实际输入或输出映射的理想化数据流，就是各种不同的输入，统一用流来表示，于是打开文件的过程就是把流和文件关联起来，读写都通过流来实现。

头文件 stdio.h 其实是两个部分组成的，stdin 和 stdout，C 把输入和输出设备都视为存储设备上的普通文件，尤其是键盘和屏幕，甚至是每个 C 程序自动打开的文件。

##### 文件结尾

在 C 中，getchar() 读取文件如果检测到文件结尾返回一个特殊值 EOF ，end of file 的缩写，scanf() 函数也是一样会返回 EOF。EOF 定义在 stdio.h 中：`#define EOF -1`。因为 getchar 通常返回 0~127，对应标准字符集，可拓展系统可能会返回 0~255，无论如何 -1 都不对应任何字符，所以可以用来判断文件结尾。

 关键要理解 EOF 是一个值，不是在文件末尾能找到的符号。可以将 getchar 的值与 EOF 比较：`getchar()!=EOF`，此时如果读取的是键盘输入也没有关系，因为大部分系统都有办法通过键盘模拟文件结尾。

##### 重定向和文件

`<` 符号 UNIX DOS WINDOWS 的重定向运算符，`echo_eof < words`，这段代码让 words 文件与 stdin 流相关联，把文件中的内容导入 echo_eof 程序。程序并不知道也不关心输入的内容是从哪里来的，它只知道那就是需要导入的字符流，然后执行程序其它命令，直到遇到结尾。**C 把文件和 I\O 设备放在一个层面，所以文件现在就是现在的 I\O 设备。**

`>` 符号也是重定向运算符，`echo_eof > mywords` 创建一个 mywords 新文件，然后把 echo_eof 的输出重定向到该文件中，该段代码把 stdout 流从显示设备赋给 mywords 文件，如果已经存在 mywords 文件，就擦除其中内容然后替换成新的内容

制作一份 mywords 文件的副本，并命名为 savewords，只需要下列命令：

`echo_eof < mywords > savewords`

`echo_eof > savewords < mywords`

命令与重定向运算符的顺序无关，以上两条的效果一样。在像上面同时有两种运算符重定向的命令中，输出和输入文件名不能相同，因为上面有提到，在 > mywords 执行输入之前， mywords 的长度就被截断为 0。