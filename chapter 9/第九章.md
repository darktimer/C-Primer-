

## 使用函数

开头要声明**函数原型**，还要由主调函数执行**函数调用**，最关键的是要有**函数定义**，明确写出函数的**功能。**
**函数原型：**指明了函数的返回值类型和参数类型，这些叫做**签名**。

把函数，包括主函数，都放到一个文件中以单文件的形式存储比较容易编译，当然也可以放到两个文件中，这样方便其他程序调用。

**局部变量：**函数体内部声明的变量，只在函数体内有效，其他函数中有相同名称的变量不会影响使用，因为在内存中不是同一个变量，这里先提一下，函数中的变量是用栈存储的，不同的函数有不同的栈。所以函数的参数只是主调函数传给的变量的拷贝值，在函数中修改并不能影响主调函数中的实参，如果用指针变量做参数直接链接到内存中的地址，就可以做到在函数中修改主函数的变量值。

## 带参数的函数

声明函数原型时需要指明参数的类型和数量，变量名可以省略。即使声明函数原型时指定了变量名，也不会再实际中创建变量，因为是函数的私有变量。

主调函数的实际参数可以是常量、变量甚至时复杂的表达式，无论是什么形式，最终都要求值，并把值拷贝给函数的形式参数。

用于测试函数而创建的简单程序有时被称作**驱动程序**，如果函数测试正常，就可以在更重要的程序中使用。

当函数需要返回 return 给主调函数一个值的时候，如果是一个复杂的表达式，最好是用括号括起来，比较规范。

------

return ；可以这样用，在 void 的函数中。这一点是之前不知道的，虽然现在没发现在 void 函数中不写 return；的后果，但之前程序还没有过错误提示，也就没注意这个问题，以后要记得！

------

C 的早期，没有声明类型的函数会被默认为 int 类型，但从 C99 开始不再有。

函数声明要写在使用函数之前。

## ANSI C 函数原型

以前的标准，声明函数没有参数会导致问题。

float 类型被作为参数传递时会被升级为 double 类型。

如果要传递的值，即实参和形参的类型不匹配，编译器会把实参的类型转换成形参的类型。

不声明函数原型也可以，但必须把整个函数定义放在函数调用的前面。

## 递归

printf 用 %p 打印内存地址，如果不支持，用 %u 或 %lu 代替。

递归函数必须包含能让递归停止的语句。通常使用 if 条件判断语句，当递归函数的形参等于特定值时就停止。

每一次递归都会创建一组变量，这些变量存储在栈中，使用的内存空间就越多，因此递归的执行速度是比较慢的。

## 编译多源代码的文件

为了防止每个文件都要加载相同的例如符号常量等一些内容，最好的办法是将他们写在头文件中。

------

第四章中的在 printf 和 scanf 中可以使用 * ，printf 中是用来代替字段宽度，scanf 中是用来跳过使用 * 的占位符。所以 scanf("%*s"); 可以起到和第八章 md 中跳过剩余输入内容的作用。

在条件测试语句中，规则是从左往右对逻辑表达式求值，一旦为假，立即停止求值。

通过做第八章的习题发现自己有个毛病，还没等程序的正常功能测试完成就想完成包括输入检测的一些附加功能，正确的思想是先完成程序的正常功能，先跑通，完成基本板块功能，然后再完善，改善。即使完善功能时可能需要大段代码重写，这也是正确的做法，慢慢练习，有了经验以后，需要重写的就可以预先知道怎么最大程度规避了。

------

## & 查找地址运算符

别害怕指针，灵活运用指针才是真的 C 。

**指针：用于存储变量的地址。** & 运算符给出变量的存储地址，例如 pooh 是变量名，&pooh 表示的是 pooh 的地址，变量在内存中的位置， 使用 %p 来打印地址。

## * 间接运算符

也叫解引用运算符，作用是给出存储在指针指向地址上的值。

```
nurse = 2;
ptr = &nurse; //指向 nurse 的指针
val = *ptr; //把 ptr 指向地址上的值赋给 val ，等同于 val = nurse;
```

## 声明指针

```
int* pi;
```

`*` 表明声明的变量是一个指针，上面声明的意思是，pi 是指针，*pi 是 int 型。通常认为 pi 指针是无符号整数，而不是 int 型，指针其实是和 int 同级的一种数据型，有单独的 %p 转换说明也显示出这一点。

## 小结

在写程序时，模块化函数现在已经做到了，但是一遇到需要验证输入这类型的需求时，一些细节上的东西就会卡壳，还是模块化的概念没有理解好，把函数签名想好，返回值利用好，上下文逻辑搞清楚，慢慢调整。

另外以前学习 C 语言在利用函数时并没有太多涉及到指针，实际上灵活运用指针是非常重要的，今后要多试着用指针解决问题，当然，目前，需要在函数中修改主调函数的变量值才会用到指针。

------

类似第五章中，对递增运算符和递减运算符的描述，如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符。

类似的9-6题：

```
printf("min: %.2lf, middle: %.2lf, max: %.2lf\n", getMin(&temp1, &temp2, &temp3), temp2, temp3);
```

如果在 getMin 函数中，*temp2 和 *temp3 的值有变化，尽管参数用了指针，但还是不会影响到 printf 函数中的 temp2 和 temp3 的！！！！！！

可能是跟第八章 8-8 的那个函数传参数是从右到左的顺序有关，碰到嵌套函数，如果一个变量同时出现在嵌套函数的参数列表中，一定要注意传参和执行顺序，别想一步到位：

```
min = getMin(&temp1, &temp2, &temp3);
printf("min: %.2lf, middle: %.2lf, max: %.2lf\n", min, temp2, temp3);
```

