[TOC]

## 数组

**初始化：**可以用｛｝来初始化数组的每个元素。如果知道数组的大小，最好用 #define 来定义符号常量，便于修改。如果初始化数组后就不需要修改数组元素，那么用 const 修饰数组名也是推荐的操作，一旦用 const 修饰后，只能检索数组，不能修改内容。

```
int a[3]={1,2,3};
```

使用数组之前必须初始化，这一点和普通变量类似，声明了变量名只是在内存上划定了一个区域，这个区域很有可能不是空的，原来就有一些值，这样可能会引起未知的错误。部分初始化也是可以的，剩余的元素编译器会自动初始化为零，但如果初始化时的元素个数超出了声明的数组空间，就会发生错误了。

```
int a[]={1,2,3}
```

在明确知道具体元素时，可以在声明数组的时候省略方括号中的数字，编译器会根据｛｝中的元素个数自动匹配数组空间。这个时候人工计算数组大小可能会出错，使用下面的方法计算数组大小比较好：

```
sizeof a / sizeof a[0];
```

sizeof a 是整个数组的大小，sizeof a[0] 是单个元素的大小，相除就是数组元素的个数。

## C99 指定初始化器 designated initializer

意思就是初始化列表中使用方括号下标指定待初始化的元素。int arr[6]={ [5] = 212 }. 

这里有一个点，当初始化数组中任意元素后，其他元素都被自动设置为 0 。

```
int arr[] = { [6] = 4, 9 ,10 };
```

上行代码，在指定 [6] 元素为 4 后，9 和 10 将被依次安排到 [7] 和 [8] 的位置，而且，声明时未指定数组大小，编译器将根据初始化的值来设置数组大小足以容纳所有值。如果在初始化列表中出现给同一个位置初始化两次值，那么以最后一次指定为准。

以上仅 C99 支持。

## 给数组元素赋值

可以使用 for 循环给数组元素赋值，但这已经不叫初始化，初始化是在声明的时候就赋值。

数组之间不可以直接赋值，arr1[size] = arr2[size] 这样是错的，别问，问就是 C 不让。

另外，只有初始化数组时才可以用初始化列表 { } ，之后给数组赋值时不可以用这种形式。

在给数组元素赋值时一定要人工检查数组的边界，C 编译器不会检查越界问题！！！所以数组大小最好使用 #define 宏定义符号常量（预处理器可用来定义常量，也叫明示常量）来指定。

## 多维数组

即数组的数组，遇到这样的声明可以这样看，float rain [5] [12]，先看到 rain[5] 是一个有 5 个元素的数组，再看到 float [12] 说明每个 rain 元素是一个内含 12 个 float 类型元素的数组。

多维数组的赋值和一元数组的赋值遵循一样的规则。

## 指针和数组

数组表示法其实是在变相的使用指针！！！

**数组名是数组首元素的内存地址**，指针 + 1 是增加一个存储单元，而不是单纯增加一个字节。

```
date + 2 = &date[2];
*(date + 2) == date[2];
```

上面的代码表示数组和指针的关系十分密切，可以使用指针表示数组元素和取得元素的值。其中 *(date + 2) 表示到内存 date 的位置，然后偏移 2 个存储单元，然后取值，这里的括号不可省略，如果省略了就变成  *date + 2 即第一个元素的值加 2 。

可以用指针表示数组，那么反过来也可以用数组表示指针，所以在使用数组作参数的函数时要特别注意。

## 函数、数组、指针

**函数的实际参数是数组，那么函数原型中的形参应该是一个指针型的变量，类型匹配数组的类型。**因为前面提到，数组名就是数组首元素在内存中的地址。

因为数组元素是在内存中是相邻存储的，所以知道了首元素后，按照存储单元的大小就可以找到所有数组元素了。

```
int* ar 和 int ar[] 都表示 ar 是一个指向 int 的指针。

int example(int [] , int);
int example(int* , int);
```

以上提供两种参数带数组的函数原型声明。

```
#include <stdio.h>

#define SIZE 10
int sum(int ar[], int n);

int main(void){
	int marbles[SIZE] = { 20,10,5,39,4,16,19,26,31,20 };
	long answer;
	
	answer = sum(marbles, SIZE);
	printf("The total number of marbles is %ld.\n", answer);
	printf("The size of marbles is %zd bytes.\n", sizeof marbles);
	
	return 0;
}

int sum(int ar[], int n){
	int i, total = 0;
	
	for(i = 0; i < n; i++)
		total += ar[i];
	printf("The size of ar is %zd bytes.\n", sizeof ar);
	
	return total;
}
```

输出如下：

```
The size of ar is 8 bytes.
The total number of marbles is 190.
The size of marbles is 40 bytes.
```

解释一下，因为 marbles 是一个 int 类型的数组，存有 10 个元素，所以 size 大小是 4 * 10 = 40 bytes，而 ar 是函数定义头中一个指向 marbles 数组首元素地址的指针，

虽然声明函数原型时用了 [ ] 数组形式，**上一节有一点没有提到：**当函数实际参数是数组时，因为数组名是该数组首元素地址的原因，实际参数要求形式参数是一个与之匹配的指针，此时 C 才会把 int ar[] 和 int* ar 解释成一样，意为 ar 是指向 int 的指针。

所以 ar 的大小是内存中地址的存储大小，这就跟系统有关系了，8 bytes 表示该程序运行的系统使用 8 bytes 存储地址。

**切记，在函数的参数中出现数组名时，对应的形参应该是一个指针！**

**这也是上节提到的，利用 C 中数组和指针的特殊关系，可以用 *数组表示法* 来表示指针！**

```
answer = sump( marbles, marbles + SIZE)
while (start < end)
```

C 保证在给数组分配空间时，**指向数组后面第一个位置的指针仍然有效**， 即 marbles + SIZE 已经是数组后面的第一个位置了，也就是 end ，所以 while 的循环条件是没有问题的。使用这种方式直接传递数组的边界比较简洁。

```
total += *start++;
```

一元运算符 * 和 ++ 的优先级相同，**但结合律是从右到左的，**所以 start++ 先求值，然后才是 *start ，而且这里不能加括号，( *start)++ ，这样就变成了递增值而非指针。所以 *(start++) 这样写更清晰。

------

~~指针递增跟普通变量递增不同，在当前循环就执行了，不是等到下个循环才生效，见 10-2.c~~ 

一样一样，我理解错了，写在循环条件里的才是下个循环生效，实际上是当前语句执行完后就递增了。(误)

------

下面对比一下：

```
int data[2] = { 100, 200 };
int moredata[2] = { 300, 400 };
int main(void){
	int* p1, *p2 , *p3;
	p1 = p2 = data;
	p3 = moredata;
	printf(" *p1 = %d, *p2 = %d, *p3 = %d\n", *p1, *p2, *p3);
	printf(" *p1++ = %d , *++p2 = %d, (*p3)++ = %d\n", *p1++, *++p2, (*p3)++);
	printf(" *p1 = %d, *p2 = %d, *p3 = %d\n", *p1, *p2, *p3);
}

output:
*p1 = 100		*p2 = 100		*p3 = 300
*p1++ = 100		*++p2 = 200		(*p3)++ = 300
*p1 = 200		*p2 = 200		*p3 = 301
```

这里有个盲点，一次声明多个指针变量时，每个变量名前都要加 * 才能成功，否则只有第一个是指针变量，其他都是普通类型。

## 指针表示法和数组表示法

处理数组的函数实际上用的是指针作为参数，但用数组表示法会更突出处理的是数组这个意图，而指针表示法更接近机器语言，尤其是与递增运算符连用的时候，所以有些编译器也会比较高效的生成代码。

## 指针基本操作

演示 8 种基本操作，是否还记得指针的转换说明是 %p ？如果不支持 %p 就用 %lu 或 %u 代替，另外这里介绍，使用 %td 打印地址的差值，如果不支持，用 %d 或 %ld 代替。

**指针与整数相加**，对应到数组，就是求以加法结果为下标的数组元素地址，而实际上加法在运算时，是将整数乘上指针的类型大小，以字节为单位，然后再把结果与指针的地址相加，对应到 10.13.c 的程序中，ptr1 + 4 与 &urn[4] 的效果是等价的。实际上理解为，指针偏移 4 个存储单元，而每个存储单元是 int 类型 4 字节，所以在内存上共偏移了 16 字节，指针偏移到了数组第 4 个元素的地址。此时如果偏移结果超出数组边界，结果是没有定义的，所以需要特别注意人工检查边界问题，不过就像上面提到的，如果刚好偏移到数组后面第一个位置，这个指针 C 语言仍然保证有效。

解引用若果是数组后面第一个位置也可以，但超出就不可以了。

**但解引用未初始化的指针是严重的错误！！！**比如：

```
int* pt;
*pt = 5;
```

本意是把 5 存储在 pt 指向的位置，但 pt 未被初始化，是一个随机值，所以 5 存储在哪里也是一个随机，这样的话可能导致的问题就相当严重了，因为随机指定的 pt 可能指向内存的任意位置！

**切记：**创建一个指针，系统只分配存储指针本身的内存，但存储数据的内存是没有分配的！可以用现有变量的地址来初始化，也可以用后边会学到的 malloc 函数分配内存。**无论如何，不要解未初始化的指针。**

------

之前 9-6 题，调用函数时参数用了指针，然后函数体里要用临时指针变量，就创建了一个，但未初始化，然后报错，然后声明并初始化了一个普通临时变量，用这个变量的地址初始化了临时指针变量才可以。

------

**补充内容：**之前指针操作全部忽略了，现在补全，具体见 10.13.c

递增指针： 相当于让指针移动指向至数组的下一个元素。所以 ptr1++ 相当于把 ptr1 的值加上指向数据类型的大小比如 int 是 4 ，ptr1 指向了 urn[1] 。

递减指针：跟递增道理相同。

指针加整数、减整数：**相加时顺序可以交换，但减整数时指针必须做第 1 个运算对象。** ptr1 + 4 = &urn[4] , ptr3 - 2 = &urn[2] 。加、减的结果如果正好超过数组末尾第一个位置，则保证有效，再超了就结果未定义了。

------

## 保护数组中的数据

如上面所讲，在调用函数的参数中有数组时，那么传递参数使用的实际上是指针，这样就可能会无意间在函数中通过指针修改数组元素的值，再或者碰到有的函数需要修改数组元素的值，另外的函数不需要修改，这是就需要关键字 const 。

在声明函数原型时，就考虑函数的功能中要不要修改数组元素的值，如果不需要，就在参数名前加一个 const 关键字，效果和变量名前加 const 一样，而数组声明时不需要，只是在调用函数时按照需要加。

const 也可以用来修饰指针变量，意思是这个指针变量不能用来修改它指向的值，不管它指向的地址的变量是不是 const 。

普通数据，无论是不是 const ，给 const 的指针初始化或赋值都可以。

但是普通的指针，只能接受非 const 的数据。

这样就做到指针无法修改 const 的数据。

const 还可以限制指针指向的位置： double* const pc = rates ，rates 是数组名，这个意思是 pc 只能指向数组的开始，不能再指向其他位置，当然，如果数组不是 const 的话那么这时可以改变这个位置上的值，但就是不能指向其他位置。 在这个基础上还可以再加 const ，const double* const pc = rates ，这样声明，该指针既不能改变它所指向的地址，也不能修改指向地址上的值。

## 指针和多维数组

```
int zippo[4][2]

对于这个内含 int 数组的数组作下分析:

//之前讲过二维数组可以这样看：先看到 zippo[4] , 然后看到 int [2]。
zippo == &zippo[0];		//数组名 zippo 是数组首元素 zippo[0] 的地址
zippo[0] == &zippo[0][0];	//zippo[0] 是 int [2] 的首元素，内含两个 int ,即 zippo[0][0] 和 zippo[0][1] ，递归一下结论不难理解。

zippo + 1 ≠ zippo[0] + 1;
//zippo 占用两个 int 大小（可以理解为其下标中又有行又有列同时变），aippo[0] 占用一个 int 大小（可以理解为其下标中行已经确定，只有列在变）

*zippo == zippo[0];	//第 6 行推导
*(zippo[0]) == zippo[0][0];	//第 7 行推导
*zippo == &zippo[0][0]; //第 6、7 行共同推导
**zippo == zippo[0][0]; //上行推导
```

上面的推导引出了**地址的地址**，地址的地址**或指针的指针**就是**双重间接**的例子。需要解引用两次才能获得原始值即第 15 行。具体见 10.15.c

该程序中有一个指针表示法 * ( *( zippo + 2 ) + 1 ) ，对应的数组元素是 zippo [ 2 ] [ 1 ] ，所以可以体会到，如果数组是多维的，越多维，用指针表示就越复杂。

## 指向多维数组的指针

```
int (*pz)[2]; // pz 指向一个内含两个 int 类型数值的数组
			 // 可以理解为数组中每个元素有两个 int 值
			 // 首先看到 *pz , 说明是指针
			 // 再看到 int [2] , 说明指针指向包含两个 int 元素的数组
			 
//注意 [] 和 * 的优先级，声明中要特别注意， [] 的优先级比 * 高！..首先看到..再看到..的原因
			 
int* pax[2];  // pax 指向一个内含两个指针元素的数组，每个指针元素指向 int 类型的值。
			 // 可以理解为一个 int 数组包含两个元素，每个元素都是一个指针变量，指向 int
			 // 首先看到 pax[2] , 说明是数组
			 // 再看到 int* , 说明是指向 int 的指针

详细例子见 10.16.c ，多看多理解
```

## 指针的兼容性

这章的内容非常生硬，比较绕。不过要记住，指针指向的永远是地址，指针的指针指向的还是是指针的地址，多重指针用递归的概念来理解，慢慢来，多看示例程序理解。

指针之间的赋值比数值类型之间赋值要严格的多。**一定要 类型匹配！！！**包括基本数值类型 int、double etc.和数据类型 数组、指针、指针的指针。赋值时一定要对应好。

```
int n = 5;
double x;
int* p1 = &n;
double* pd = &x;
x = n;	//这里是隐式类型转换，把 int 赋给 double ,只会警告不会报错
pd = p1;	//指针指向类型不匹配，会直接报错，编译错误

更复杂的声明-----------------------------------------------------

int* pt;
int(*pa)[3];
int ar1[2][3];
int ar2[3][2];
int** p2;	//指向指针的指针

pt = &ar1[0][0];	//指向 int 的指针
pt = ar1[0];	//指向 int 的指针
pt = ar1;	//无效, ar1 = &ar1[0]，pt 是指向 int 的指针，ar1 是指向数组的指针
pa = ar1;	//都是指向 int 数组的指针，数组内含 3 个 int 类型元素
pa = ar2;	//无效
p2 = &pt;	//都是指向 int 的指针
*p2 = ar2[0];	//都是指向 int 的指针
p2 = ar2;	//无效

最后两个这样看： 
p2 是一个指向指针的指针，它指向的指针指向 int 类型，
ar2 是指向 int  类型数组的指针
类型不符，所以不能把 ar2 赋给 p2。
而 *p2 是指向 int 的指针，与 ar2 类型兼容
ar2[0] = &ar2[0][0]
所以 *p2 = ar2[0] 可以
```

前面提到，把 const 指针赋给非 const 指针是不安全的行为，因为新的指针可以改变 const 指针指向的数据。而把非 const 指针赋给 const 是没问题的，但只能解一层引用，有多层解引用的时候也不安全。

```
int x = 20;
const int y = 23;
int* p1 = &x;
const int* p2 = &y;
const int** pp2;
p1 = p2;	//不安全 把 const 指针赋给非 const 指针
p2 = p1;	//有效 把非 const 指针赋给 const 指针
pp2 = &p1;	//不安全 嵌套指针类型，多次解引用
--------------------------------------------------
const int** p2;
int* p1;
const int n = 13;

pp2 = &p1;	//允许，但会导致 const 限定符失效，因为赋值了
*pp2 = &n;	//有效，两者都是 const ，但将导致 p1 指向 n , 上一行 *pp2 已经修改
*p1 = 10;	//有效，但会导致 const 限定符失效，因为改变了 n 的值
```

再次说明：**通过非 const 指针修改 const 数据是未定义的！**

## 指针和多维数组

要使用处理二维数组的函数，一定要搞明白指针的概念才能正确的写出函数原型的声明。

```
void fun(int (*)[NUM], int rows);
void fun(int [][NUM], int rows);	//两种都是正确的，省略了形参名的写法，亲测有效
					  			//调用函数时直接传入二维数组名即可
					  		 //二维数组的两个 [] 只能省略前一个，原理还是数组的指针表示法
void fun(int ar[][4], int rows);	//表示 ar 指向一个内含 4 个 int 类型元素的数组，这样 								   //ar[1] 转换成 ar + 1 后表示 ar 偏移 1 个 int 即 4 个字
								 //节，如果第 2 个括号也省略,不写编译器就不知道怎样处理
void fun(int ar[3][4], int rows); 	//也是正确有效的，但 3 将被编译器忽略
```

使用 typedef 也可以达到效果

```
typedef int arr4[4];	//arr4 是一个内含 4 个 int 的数组
typedef arr4 arr3x4[3]; //arr3x4 是一个内含 3 个 arr4 的数组
int sum2(arr3x4 ar, int rows);
int sum2(int ar[3][4],int rows);
int sum2(int ar[][4],int rows);	//标准形式
```

反正就是声明指向 N 维数组的指针时，只能省略最左边的括号中的值。因为第一个 方括号 表示这是一个指针，其他方括号表示指针指向的数据对象的类型（数组）。

## 变长数组 VLA

（一开始还没注意到）声明多维数组时，行要单列在函数参数中，而列却在函数体中。这是因为 C 规定，数组的**维数**必须是常量，不能用变量来代替。

对于这样的情况 C99 有了变长数组 VLA 的特性，允许使用变量表示数组的维度。

```
int row=0,column=0;
double arr[row][column];	//变长数组
```

之前提到变长数组有限制，必须是自动存储类别，意味着无论在函数中声明还是作为函数形参声明，都不能使用 static 或 extern 存储类别说明符，后面会介绍。**而且不能在声明中初始化**。在 C11 中变为一个可选特性而非必须。

注意！变长数组的变不是指维度可以变化或可以修改已创建数组的大小，而是维度可以是变量。一旦创建了变长数组，它的大小是不变的。

声明变长数组时需要注意，作为维度的常量要比数组名先声明，写在前边。

```
int sum2d(int rows, int cols, int ar[rows][cols]);	//ar 是一个 VLA
int sum2d(int ar[rows][cols], int rows, int cols);	//无效顺序
int sum2d(int , int ,int ar[*][*]);	//省略了维度形参名，用 * 代替，但 ar 不能省略
```

不难推断变长数组允许动态内存分配，在程序运行时可以指定数组大小，但普通数组都是静态内存分配，在编译时就要准确知道数组大小，因为是常量。

## 复合字面量

**复合字面量**是除符号常量外的常量。

C99 新增的，使用场景是：一个函数的参数中有 int 类型，那么可以传给它 int 型的变量，也可以直接传递 int 型常量比如 5 ，但如果函数的参数是数组，却没有等价的数组常量，所以引出了复合字面量。例如 5 是 int 类型字面量，81.3 是 double 型字面量，'y' 是 char 型字面量，"elephant" 是字符串字面量。

下面看怎样声明：

```
int diva[2] = {10, 20};
(int [2]){10, 20}; 	//复合字面量
(int []){10, 20};
```

上面的复合字面量创建了一个和 diva 数组相同的匿名数组。

数组的复合字面量类似数组的初始化列表，去掉声明中的数组名，留下的 int[2] 就是复合字面量的类型名。

和数组一样，在初始化复合字面量时也可省略数组大小，会自动识别元素个数。

因为声明的复合字面量是匿名的，所以不能先创建后使用，必须创建的同时就使用。而如果使用指针来记录匿名复合字面量的地址的话，就可以为所欲为了。

```
int* pt1;
pt1 = (int [2]){10, 20};
// 和普通数组一样，复合字面量的类型名也是首元素的地址
*pt1 == 10    pt[1] == 20 //注意后一个的写法
```

把复合字面量作为实际参数传递给带有匹配形式参数的函数：

```
int sum(const int ar[], int n);
...
int total3;
total3 = sum((int []){4,4,4,5,5,5}, 6);
```

第 1 个实参内含 6 个 int 类型值的数组，和数组名类似，同时也是该数组首元素的地址，这种使用的好处是在传入函数时不必先创建数组，这是复合字面量的典型用法。

这种用法应用于二维数组或多维数组。

```
int (*pt2)[4];	//声明一个指向二维数组的指针，该数组内含 2 个数组元素
			   //每个元素内含 4 个 int 类型值的数组
pt2 = (int [2][4]){ {1,2,3,-9}, {4，5，6，-8} };
```

综合来说，复合字面量是提供一种临时量的手段，它具有块作用域，一旦离开定义复合字面量的块，无法保证其还存在，或者说它只存在最内层的括号中。

------

数组存储了相同类型的数据，算是**派生类型**，建立在一般数据类型的基础上，也可以是数组的数组即多维数组。

通常为了处理数组相关的特定问题，会编写一个函数来模块化处理，在传递数组把数组名作为实参的时候，传递的实际上是数组的地址，而函数对应的形参是指针。处理数组需要知道首元素的地址和元素个数，通常作为函数的两个参数传递，这样便于处理不同大小的数组。

C 把数组名解释为该数组首元素的地址，这实际上是与指针等价的，如果 ar 是一个数组，那么 ar[i] 和  *(ar + i) 是等价的。

------

注意练习题的 4 和 5 题。

```
4. *ptr 和 *(ptr + 2) 的值？

a. 
int* ptr;
int torf[2][2] = {12, 14, 16};
ptr = torf[0];					// *ptr = 12  *(ptr + 2) = 16

b.
int* ptr;
int fort[2][2] = {{12}, {14, 16}};
ptr = fort[0];					// *ptr = 12  *(ptr + 2) =14

//ptr 指向第 1 个元素，ptr + 2 指向第 3 个元素即第 2 行第 1 个
```

注意直接就能从  *(ptr + 2) 判断指向数组的第几个元素。上面提过用数组表示多维数组的写法，挺长的那个。

```
5. **ptr 和 **(ptr + 1) 的值？
a.
int (*ptr)[2];
int torf[2][2] = {12, 14, 16};
ptr = torf;						//**ptr = 12  **(ptr + 1) = 16

b.
int (*ptr)[2];
int fort[2][2] = {{12}, {14, 16}};
ptr = fort;						//**ptr = 12  **(ptr + 1) = 14

ptr 指向第 1 行， ptr + 1 指向第 2 行第 1 个元素
```

```
推导一下:
ptr = fort;		    	fort = &fort[0];	
*ptr = fort[0];			fort[0] = &fort[0][0];		
**ptr = fort[0][0];

ptr = fort;				fort = &fort[0];		ptr + 1 = &fort[1];	//fort+1 是错误表示法，fort是数组名
*(ptr + 1) = fort[1];	 fort[1] = &fort[1][0];		
**(ptr + 1) = fort[1][0];
```

