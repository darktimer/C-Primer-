## 数组

**初始化：**可以用｛｝来初始化数组的每个元素。如果知道数组的大小，最好用 #define 符号常量来定义，便于修改。如果初始化数组后就不需要修改数组元素，那么用 const 修饰数组名也是推荐的操作，一旦用 const 修饰后，只能检索数组，不能修改内容。

```
int a[3]={1,2,3};
```

使用数组之前必须初始化，这一点和普通变量类似，声明了变量名只是在内存上划定了一个区域，这个区域很有可能不是空的，原来就有一些值，这样可能会引起未知的错误。部分初始化也是可以的，剩余的元素编译器会自动初始化为零，但如果初始化时的元素个数超出了声明的数组空间，就会发生错误了。

```
int a[]={1,2,3}
```

在明确知道具体元素时，可以在声明数组的时候省略方括号中的数字，编译器会根据｛｝中的元素个数自动匹配数组空间。这个时候人工计算数组大小可能会出错，使用下面的方法比较好：

```
sizeof a / sizeof a[0];
```

sizeof a 是整个数组的大小，sizeof a[0] 是单个元素的大小，相除就是数组元素的个数。

## C99 指定初始化器 designated initializer

意思就是初始化列表中使用方括号下标指定待初始化的元素。int arr[6]={ [5] = 212 }. 

这里有一个点，当初始化数组中任意元素后，其他元素都被自动设置为 0 。

```
int arr[] = { [6] = 4, 9 ,10 };
```

上行代码，在指定 [6] 元素为 4 后，9 和 10 将被依次安排到 [7] 和 [8] 的位置，而且，声明时未指定数组大小，编译器将根据初始化的值来设置数组大小足以容纳所有值。如果在初始化列表中出现给同一个位置初始化两次值，那么以最后一次指定为准。

以上仅 C99 支持。

## 给数组元素赋值

可以使用 for 循环给数组元素赋值，但这已经不叫初始化，初始化是在声明的时候就赋值。

数组之间不可以直接赋值，arr1[size] = arr2[size] 这样是错的，别问，问就是 C 不让。

另外，只有初始化数组时才可以用初始化列表 { } ，之后给数组赋值时不可以用这种形式。

在给数组元素赋值时一定要人工检查数组的边界，C 编译器不会检查越界问题！！！所以数组大小最好使用 #define 宏定义符号常量（预处理器可用来定义常量，也叫明示常量）来指定。

## 多维数组

即数组的数组，遇到这样的声明可以这样看，float rain [5] [12]，先看到 rain[5] 是一个有 5 个元素的数组，再看到 float [12] 说明每个 rain 元素是一个内含 12 个 float 类型元素的数组。

多维数组的赋值和一元数组的赋值遵循一样的规则。

## 指针和数组

数组表示法其实是在变相的使用指针！！！

**数组名是数组首元素的内存地址**，指针 + 1 是增加一个存储单元，而不是单纯增加一个字节。

```
date + 2 = &date[2];
*(date + 2) == date[2];
```

上面的代码表示数组和指针的关系十分密切，可以使用指针表示数组元素和取得元素的值。其中 *(date + 2) 表示到内存 date 的位置，然后偏移 2 个存储单元，然后取值，这里的括号不可省略，如果省略了就变成  *date + 2 即第一个元素的值加 2 。

可以用指针表示数组，那么反过来也可以用数组表示指针，所以在使用数组作参数的函数时要特别注意。

## 函数、数组、指针

函数的实际参数是数组，那么函数原型中的形参应该是一个指针型的变量，类型匹配数组的类型。因为前面提到，数组名就是数组首元素在内存中的地址。

因为数组元素是在内存中是相邻存储的，所以知道了首元素后，按照存储单元的大小就可以找到所有数组元素了。

```
int* ar 和 int ar[] 都表示 ar 是一个指向 int 的指针。

int example(int [] , int);
int example(int* , int);
```

以上提供两种参数带数组的函数原型声明。

```
#include <stdio.h>

#define SIZE 10
int sum(int ar[], int n);

int main(void){
	int marbles[SIZE] = { 20,10,5,39,4,16,19,26,31,20 };
	long answer;
	
	answer = sum(marbles, SIZE);
	printf("The total number of marbles is %ld.\n", answer);
	printf("The size of marbles is %zd bytes.\n", sizeof marbles);
	
	return 0;
}

int sum(int ar[], int n){
	int i, total = 0;
	
	for(i = 0; i < n; i++)
		total += ar[i];
	printf("The size of ar is %zd bytes.\n", sizeof ar);
	
	return total;
}
```

输出如下：

```
The size of ar is 8 bytes.
The total number of marbles is 190.
The size of marbles is 40 bytes.
```

解释一下，因为 marbles 是一个 int 类型的数组，存有 10 个元素，所以 size 大小是 4 * 10 = 40 bytes，而 ar 是函数定义头中一个指向 marbles 数组首元素地址的指针，

虽然声明函数原型时用了 [ ] 数组形式，**上一节有一点没有提到：**当函数实际参数是数组时，因为数组名是该数组首元素地址的原因，实际参数要求形式参数是一个与之匹配的指针，此时 C 才会把 int ar[] 和 int* ar 解释成一样，意为 ar 是指向 int 的指针。

所以 ar 的大小是内存中地址的存储大小，这就跟系统有关系了，8 bytes 表示该程序运行的系统使用 8 bytes 存储地址。

**切记，在函数的参数中出现数组名时，对应的形参应该是一个指针！**

**这也是上节提到的，利用 C 中数组和指针的特殊关系，可以用 *数组表示法* 来表示指针！**



