[TOC]



## 表示字符串

第 4 章介绍过，字符串以空字符 '\0' 结尾的 char 类型数组，所以指针和数组的关系可以引申应用到字符串。

**puts( )** 函数是专门用来打印字符串的，而且在末尾自动添加 '\n' 。

### 定义字符串的方法

**字符串常量**，也叫字符串字面量。

双引号中的字符，和编译器自动添加在末尾的 '\0' 都算字符串常量。 如果在一个 char 数组中出现的多个字符串常量之间没有空隙、或者空白字符分隔， C 都将它们视为一个完整的字符串常量。

**静态存储类别：**在整个程序生命周期只存储一次，一直存在。**用双引号包含的内容，被视为指向该字符串存储位置的指针，所以可能会遇到这种表示：*"we are we are" **

如果用指针占位符 %p 打印字符串 "we are we are" ，打出的是这个字符串的地址，**因此字符串实际上代表它的地址。**

### 字符串数组定义、初始化

初始化 char 字符串数组的时候一定要记得最后的空白字符 '\0' ，如果没有的话就变成字符数组了。

在指定数组长度时，要给空白字符 '\0' 预留，预留多的会自动初始化为空字符。

**最方便的是忽略数组大小直接初始化，让编译器自动计算大小。**这样做也是合理的，因为处理字符串的函数通常不会知道数组大小，通过数组最后的空字符来确定边界。

```
char car[] = "Tata.";
char* pt1 = "Something is pointing at me.";
char ar1[] = "Something is pointing at me.";
```

上面最后两个几乎是相同的（不同点后面说），pt1 和 ar1 都是字符串的地址。

### 数组和指针

**数组形式**初始化一个字符串后，内存中就有了对应的字符串字面量，这相当于是把字符串存储在了**静态存储区**。通常字符串作为可执行文件的一部分单独存储在数据段中，在程序载入内存后才会载入字符串，这就是说，程序开始运行时，数组才会分得内存，此时才将静态存储区中的字符串字面量拷贝到数组中，所以此时存在两个字符串，一个在静态内存中，一个在程序里的数组中。

拿上面的 ar1 数组说明，这时 ar1 被识别为数组首元素的地址，数组存的是字符串，字符串又是它自己的地址，所以 ar1 变成了一个**地址常量**，所以这时是不能改变 ar1 的，如果执行了类似 ++ar1 的操作，那么改变的是数组的存储位置，相当于改变了内存中的地址，是不允许的。但类似数组偏移下标的 ar1+1 的操作是允许的。



**指针形式**初始化一个字符串后，同样的也是在静态存储区中给字符串本身预留了空间，在程序开始运行后，给指针 pt1 留出一个存储位置，然后把字符串的地址存储在指针中，指针指向字符串的首字符，不同就在这里，这个指针变量是可以改变的，所以类似 ++pt1 的操作是允许的，它指向字符串第 2 个字符。

（所以感觉是用指针初始化比较灵活操作，用数组比较安全，不过说到安全操作，const 限定字符是个好东西）

总之，初始化数组，就是把静态存储区的字符串拷贝到数组中，初始化指针，就是把静态存储区的字符串的地址拷贝给指针。详细可看 11.3.c



