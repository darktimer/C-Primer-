[TOC]



## 表示字符串

第 4 章介绍过，字符串以空字符 '\0' 结尾的 char 类型数组，所以指针和数组的关系可以引申应用到字符串。

**puts( )** 函数是专门用来打印字符串的，而且在末尾自动添加 '\n' 。

### 定义字符串的方法

**字符串常量**，也叫字符串字面量。

双引号中的字符，和编译器自动添加在末尾的 '\0' 都算字符串常量。 如果在一个 char 数组中出现的多个字符串常量之间没有空隙、或者空白字符分隔， C 都将它们视为一个完整的字符串常量。

**静态存储类别：**在整个程序生命周期只存储一次，一直存在。**用双引号包含的内容，被视为指向该字符串存储位置的指针，所以可能会遇到这种表示：*"we are we are" **

如果用指针占位符 %p 打印字符串 "we are we are" ，打出的是这个字符串的地址，**因此字符串实际上代表它的地址。**

### 字符串数组定义、初始化

初始化 char 字符串数组的时候一定要记得最后的空白字符 '\0' ，如果没有的话就变成字符数组了。

在指定数组长度时，要给空白字符 '\0' 预留，预留多的会自动初始化为空字符。

**最方便的是忽略数组大小直接初始化，让编译器自动计算大小。**这样做也是合理的，因为处理字符串的函数通常不会知道数组大小，通过数组最后的空字符来确定边界。

```
char car[] = "Tata.";
const char* pt1 = "Something is pointing at me.";
const char ar1[] = "Something is pointing at me.";
```

上面最后两个几乎是相同的（不同点后面说），pt1 和 ar1 都是字符串的地址。

### 数组和指针

**数组形式**初始化一个字符串后，内存中就有了对应的字符串字面量，这相当于是把字符串存储在了**静态存储区**。通常字符串作为可执行文件的一部分单独存储在数据段中，在程序载入内存后才会载入字符串，这就是说，程序开始运行时，数组才会分得内存，此时才将静态存储区中的字符串字面量拷贝到数组中，所以此时存在两个字符串，一个在静态内存中，一个在程序里的数组中。

拿上面的 ar1 数组说明，这时 ar1 被识别为数组首元素的地址，数组存的是字符串，字符串又是它自己的地址，所以 ar1 变成了一个**地址常量**，所以这时是不能改变 ar1 的，如果执行了类似 ++ar1 的操作，那么改变的是数组的存储位置，相当于改变了内存中的地址，是不允许的。但类似数组偏移下标的 ar1+1 的操作是允许的。



**指针形式**初始化**指向**一个字符串后，同样的也是在静态存储区中给字符串本身预留了空间，在程序开始运行后，给指针 pt1 留出一个存储位置，然后把字符串的地址存储在指针中，指针指向字符串的首字符，不同就在这里，这个指针变量是可以改变的，所以类似 ++pt1 的操作是允许的，它指向字符串第 2 个字符。

（所以感觉是用指针初始化比较灵活操作，用数组比较安全，不过说到安全操作，const 限定字符是个好东西）

总之，初始化数组，就是把静态存储区的字符串拷贝到数组中，初始化指针，就是把静态存储区的字符串的地址拷贝给指针。详细可看 11.3.c

### 数组和指针的区别

```
char heart[] = "I love Tillie!";
const char* head = "I love Millie!";
```

初始化字符数组存储字符串 和 初始化指针指向字符串的**区别**：数组名 heart 是常量，指针 head 是变量。两者都可以用数组表示法，利用 [ ] 下标偏移访问元素，也能用指针加法操作，利用 *( ptr + i) 偏移指针访问元素。但：

head = heart；是合法的，现在 head 指向了 heart 数组。

heart = head；是不合法的。这就相当于 x = 3； 和 3 = x；的区别，赋值左侧必须是变量，行话叫**可修改的左值**。

另外，head = heart；不会导致原 head 指向的字符串消失，它还在内存中，除非还有地址指向源字符串，否则它就是幽灵数据了。赋值只是该改变了指向 heart 的地址。

**除非要修改字符串，不要用指针指向字符串字面量。**

细心点可能注意到，在使用初始化指针时都加了 const 限定符，只是因为使用指针改变字符串里的字符这个操作在不同的编译器上是难以捉摸的，经常会导致未知后果。所以如果非要用初始化指针，最好加上 const 限定符。而初始化数组是拷贝了一份字符串，所以不存在这些问题。

.....所以还是建议使用数组初始化.....

### 字符串数组

```
const char* ptr1[ROWS];//这里是 ROWS 不是 COLS ，仔细推敲，数组里有 n 个字符串，n 个指针指向
char ptr2[ROWS][COLS];
```

如果只需要表示一个字符串，那么使用指针数组，如果要修改字符串或者为字符串输入预留空间，就用二维字符数组。

